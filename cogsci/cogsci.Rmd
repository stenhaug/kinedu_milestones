---
title: "The latent factor structure of child development"
bibliography: cogsci_ref.bib
csl: apa6.csl
document-params: "10pt, letterpaper"

author-information: > 
    \author{Anonymous Cogsci Submission}

abstract: >
    Hello
    
keywords: >
    one; two;
    
output: cogsci2016::cogsci_paper
header-includes:
- \usepackage{bm}
final-submission: \cogscifinalcopy
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=3, fig.height=3, fig.crop = F, 
                      fig.pos = "tb", fig.path='figs/',
                      echo=F, warning=F, cache=F, 
                      message=F, sanitize = T)

library(tidyverse)
theme_set(theme_classic())

# load in
areas <- read_rds(here::here("data-clean/areas.rds"))
d <- read_rds(here::here("data-clean/d.rds"))
d_mat <- read_rds(here::here("data-clean/d_mat.rds"))
item_area <- areas$area[match(colnames(d_mat), areas$paste)]

fix_names <- function(x) ifelse(x == "", paste0("X__", 1:length(x) - 1), x)

d_raw <- 
  readxl::read_xlsx(
    here::here("data/norming2/Kinedu Norming Survey Raw Data - May 15 2018.xlsx"),
    .name_repair = fix_names
  )

# remove ages < 1
ages <-
    d %>%
    group_by(id) %>%
    summarize(age = age[1]) %>%
    filter(age > 1)

d_mat <- d_mat[row.names(d_mat) %in% ages$id, ]

d <- d %>% filter(age > 1)

# get milestones
milestones <-
    d_raw %>%
    select(abs_183:color_679) %>%
    slice(3) %>%
    gather(code, name) %>%
    mutate(short_name = str_sub(name, start = 0, end = 40),
           code = str_replace(code, "^d_","d"),
           code = str_replace(code, "^e_","")) %>%
    mutate(code2 = code) %>%
    separate(code2, into = c("category","number")) %>%
    select(-number)

ms <- milestones %>% mutate(code = str_remove(code, " "))
```

# Introduction

TO DO

# Data

A child’s development can be thought of as the set of developmental milestones that they have reached at a particular point in time. This conceptualization results in data with the same structure as the item response data common to educational measurement. In education, item response data is most typically students responding to test items (i.e., questions) and, in the dichotomous case, getting each question either correct or incorrect. In the context of child development, the child is the “student,” and each developmental milestone is the “item.”

We use Kinedu, a Mexico-based child development app, as a source for this type of data. When parents first start using the Kinedu app, they are asked a series of questions about which developmental milestones their child has reached. We consider the 1946 children between 2 and 55 months of age whose parents responded to all 414 of the developmental milestones. Each developmental miletone on Kinedu is mapped to a milestone group: physical, cognitive, linguistic, or social & emotional. Table \ref{tab:examples} shows the number of developmental milestones in each group along with an example milestone translated to English.

```{r examples}
areas %>%
    filter(paste %in% colnames(d_mat)) %>%
    group_by(area) %>%
    mutate(count = n()) %>%
    slice(1) %>%
    ungroup() %>%
    left_join(ms, by = c("paste" = "code")) %>%
    select(Group = area, Count = count, spanish = short_name) %>%
    select(-spanish) %>% 
    arrange(desc(Count)) %>%
    mutate(Milestone = c(
        "Stands on their toes",
        "Finds objects on the floor",
        "Babbles to imitate conversations",
        "Complains when play is interrupted"
    )) %>% 
    knitr::kable("latex", caption = "Developmental milestone groups and examples") %>% 
    kableExtra::kable_styling(font_size = 8, latex_options = "hold_position")
```

Figure \ref{fig:growth} shows the age (in months) and number of developmental milestones for each child. At 12 months old, most children have reached about 200 developmental milestones. At 24 months old, most children have reached about 300 developmental milestones. Finally, at 48 months old, most children have reached about 375 of the 414 developmental milestones.

```{r growth, fig.cap = 'Number of milestones by age', warning = FALSE}
source(here::here("data-emailed-from-mike/predictQR_fixed.R"))
library(quantregGrowth)

by_age <- 
    d %>%
    group_by(id) %>%
    summarise(
        age = age[1], 
        response = sum(response)
    )

excl <- 
    by_age %>%
    filter(age <= 1) %>%
    pull(id)

by_age <- filter(by_age, !(id %in% excl))
d <- filter(d, !(id %in% excl))

taus <-  c(0.1, 0.25, 0.5, 0.75, 0.9)

mod <- gcrq(formula = response ~ ps(age, monotone = 1, lambda = 1000), 
     tau = taus, data = by_age)

the_ages <- 1:55
newdata <- data.frame(age = the_ages)

preds <- predictQR_fixed(mod, newdata = newdata) %>%
  data.frame %>%
  mutate(age = the_ages) %>%
  gather(Percentile, pred, starts_with("X")) %>%
  mutate(Percentile = as.character(as.numeric(str_replace(Percentile, "X", "")) * 100))

ggplot(by_age, 
       aes(x = age, y = response)) + 
  geom_jitter(height = 0, width = 0, alpha = .1) +  # was width = 0.2 and alpha 0.3
  geom_line(data = preds, aes(x = age, y = pred, col = Percentile, group = Percentile)) + 
  ylim(0,nrow(milestones)) + 
  xlim(0,55) + 
  ylab("Total milestones") + 
  xlab("Age (in months)") + 
  ggthemes::scale_color_solarized() + 
  theme(legend.position = "bottom", 
        legend.title = element_text(size = 6),
        legend.text = element_text(size=6))
```

# Empirical assessment of the dimensionality of child development

We frame the assessment of the dimensionality of child development as a model comparison question. 

## Models

Item response theory offers a suite of models with which to model item response data. We adopt the notation used in @chalmers2012mirt. Let $i = 1, \ldots, I$ represent the distinct children and $j = 1, \ldots, J$ the developmental milestones. The Kinedu item response data is stored in a matrix, $y$, where element $y_{ij}$ denotes if the $i$th child has or has not achieved the $j$th developmental milestone as reported by their parent/guardian. Each model represents the $i$th child's development using $m$ latent factors $\boldsymbol{\theta}_{i}=(\theta_1, \ldots, \theta_m)$. The $j$th milestone's discriminations (i.e. slopes) $\boldsymbol{a_j}=(a_1, \dots, a_m)$ capture the latent factor loadings onto that milestone.

We fit four two-parametric logistic (2PL) models where a child’s development is represented by $m = 1, \ m = 2, \ m = 3,$ and $m = 4$ latent factors. According to the 2PL model, the probability of a child having achieved a developmental milestone is
$$
P(y_{ij} = 1 | \boldsymbol{\theta_i}, \boldsymbol{a_j}, b_j) = \sigma(\boldsymbol{a}_{j}^{\top}\boldsymbol{\theta_i} + b_j)
$$
where $b_j$ is the milestone easiness (i.e. intercept) and $\sigma(x) = \frac{e^x}{e^x + 1}$ is the standard logistic function.

The 2PL models learn the latent factor structure entirely from the data, making them exploratory. The bifactor model offers an alternative specification where each milestone loads onto a general factor $\theta_0$ and a specific factor $\theta_s$ [@cai2011generalized]. The assignment of each developmental milestone to its specific factor is an opportunity to specify the latent factor structure, making the model confirmatory as opposed to exploratory. We map each milestone to its specific factor according to the four developmental milestone groups shown in Table \ref{tab:examples}. For the bifactor model, the probability of a child having achieved a developmental milestone is 
$$
P(y_{ij} = 1 | \theta_0, \theta_s, a_0, a_s) = \sigma(a_0\theta_0 + a_s\theta_s + b_j).
$$

## Model comparison

Model comparison in IRT typically uses information criterion such as AIC and BIC [@maydeu2013goodness]. However, these methods are not guaranteed to work with modest sample sizes or misspecification [@mcdonald1995goodness]. Instead, we prefer a marginalized version of cross-validation. In essence, we partition the data into folds based on the children (i.e. the rows of the item response matrix). Then for each fold, we estimate the item parameters using all but that fold, and calculate the likelihood of that fold by integrating over $g(\theta)$. 

Mathematically and following notation similar to @vehtari2017practical, we partition the data into $K$ subsets $y^{(k)}$ for $k = 1, \ldots, K$. Each model is fit separately to each training set $y^{(-k)}$ yielding item parameter estimates which we compactly denote $\Psi_j^{(-k)}$. The predictive (i.e. out-of-sample) likelihood of $y^{(k)}$ is

$$
p(y^{(k)} | y^{(-k)}) = \prod_{i \in i^{(k)}}^{I} \int_\theta \prod_{j=1}^{J} \hat{\text{Pr}}(y_{ij}^{(k)} | \Psi_j^{(-k)}, \theta) g(\theta)d\theta.
$$

The ultimate quantity of interest for each model is the log predictive likelihood for the entire item response matrix, which is defined as

$$
\text{lpl } y = \sum_{k = 1}^{K} \log p(y^{(k)} | y^{(-k)}).
$$

## Results

Computing is done in R [@rcore], model fitting in the R package mirt [@chalmers2012mirt], and data wrangling/visualization in the set of R packages known as the tidyverse [@tidy].

## Understanding the latent factor structure

To understand each of the three factors in the best performing model, we fit the model to the the full dataset. We then estimate the factor loadings (i.e. discriminations or slopes) using a varimax rotation. The varimax rotation results in orthogonal and, therefore, more interpretable factors [@kaiser1959computer]. Figure \ref{fig:factorloadings} shows the distribution of factor loadings for each group on each of the three factors. The first factor is mainly cognitive and linguistic. The second factor is a combination of each of the groups with the strongest loadings on the physical and social & emotional milestones. The third mainly loads positively on linguistic milestones and negatively on physical milestones. 

```{r, include = FALSE}
library(mirt)
mod3 <- read_rds(here::here("scratch_mod3.rds"))
mod3_summary <- summary(mod3, rotate = "varimax")
```

```{r factorloadings, fig.cap = 'Factor loadings by group'}
mod3_summary_with_areas <-
    mod3_summary$rotF %>%
    as_tibble() %>%
    mutate(paste = row.names(mod3_summary$rotF)) %>%
    left_join(areas)

mod3_summary_with_areas %>%
    select(Group = area, F1, F2, F3) %>%
    rename(`Factor 1` = F1, `Factor 2` = F2, `Factor 3` = F3) %>% 
    gather(var, val, -Group) %>%
    mutate(val = -val) %>%
    ggplot(aes(x = val, fill = Group)) +
    ggridges::geom_density_line(alpha = 0.5) +
    facet_wrap(~ var, ncol = 1) +
    labs(
        x = "Factor loading (i.e. discrimination or slope)",
        y = "Density",
        title = "Milestone loadings by factor"
    ) +
    theme_classic(base_size = 8) + 
    theme(legend.position = "bottom", 
          legend.title = element_text(size = 6),
          legend.text = element_text(size=6),
          legend.key.size = unit(0.2, "cm"))
```

We also estimate the factor scores for each child using expected a posteriori (EAP) with a three dimensional standard normal distribution [@embretson2013item].  Figure \ref{fig:factorscores} shows the relationship between age and factor score for each factor. The first factor, perhaps unsurprisingly, has a high correlation (r = 0.90) with age. The second factor has a strong association with age from 2 to 16 months but thereafter is unrelated to age. By and large, the third factor does not have any association with age.

```{r factorscores, fig.cap = 'The first factor is highly associated with age'}
f <- fscores(mod3, rotate = "varimax")

# to find that correlation of 0.9 above
# tmp <- f %>% as_tibble() %>% mutate(age = ages$age)
# cor(hi$F1, hi$age)

f %>%
    as_tibble() %>%
    mutate(age = ages$age) %>%
    rename(`Factor 1` = F1, `Factor 2` = F2, `Factor 3` = F3) %>% 
    gather(var, val, -age) %>%
    mutate(val = -val) %>%
    ggplot(aes(x = age, y = val)) +
    geom_point(alpha = 0.1) +
    facet_wrap(~ var, ncol = 1) +
    geom_smooth() +
    labs(
        x = "Age (in months)",
        y = "Factor score"
    )
```

# Acknowledgements

We'd like to thank Kinedu for providing the data that made this research possible.

# References 

```{r}
# References will be generated automatically by Pandoc and included here.
# The following code is some latex to format the bibliography. Do not remove it.
```

\setlength{\parindent}{-0.1in} 
\setlength{\leftskip}{0.125in}
\noindent
